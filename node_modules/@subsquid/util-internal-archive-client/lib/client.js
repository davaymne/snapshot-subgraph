"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArchiveClient = void 0;
const http_client_1 = require("@subsquid/http-client");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
class ArchiveClient {
    constructor(options) {
        this.retrySchedule = [5000, 10000, 20000, 30000, 60000];
        this.url = new URL(options.url);
        this.http = options.http;
        this.log = options.log;
        this.queryTimeout = options.queryTimeout ?? 180000;
    }
    getRouterUrl(path) {
        let u = new URL(this.url);
        if (this.url.pathname.endsWith('/')) {
            u.pathname += path;
        }
        else {
            u.pathname += '/' + path;
        }
        return u.toString();
    }
    getHeight() {
        return this.retry(async () => {
            let res = await this.http.get(this.getRouterUrl('height'), {
                retryAttempts: 0,
                httpTimeout: 10000
            });
            let height = parseInt(res);
            (0, assert_1.default)(Number.isSafeInteger(height));
            return height;
        });
    }
    query(query) {
        return this.retry(async () => {
            let worker = await this.http.get(this.getRouterUrl(`${query.fromBlock}/worker`), {
                retryAttempts: 0,
                httpTimeout: 10000
            });
            return this.http.post(worker, {
                json: query,
                retryAttempts: 0,
                httpTimeout: this.queryTimeout
            }).catch((0, util_internal_1.withErrorContext)({
                archiveQuery: query
            }));
        });
    }
    async retry(request) {
        let retries = 0;
        while (true) {
            try {
                return await request();
            }
            catch (err) {
                if (this.http.isRetryableError(err)) {
                    let pause = this.retrySchedule[Math.min(retries, this.retrySchedule.length - 1)];
                    if (this.log?.isWarn()) {
                        let warn = retries > 3 || err instanceof http_client_1.HttpTimeoutError && err.ms > 10000;
                        if (warn) {
                            this.log.warn({
                                reason: err.message,
                                ...err
                            }, `archive request failed, will retry in ${Math.round(pause / 1000)} secs`);
                        }
                    }
                    retries += 1;
                    await (0, util_internal_1.wait)(pause);
                }
                else {
                    throw err;
                }
            }
        }
    }
}
exports.ArchiveClient = ArchiveClient;
//# sourceMappingURL=client.js.map