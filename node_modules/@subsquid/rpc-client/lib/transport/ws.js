"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsConnection = void 0;
const assert_1 = __importDefault(require("assert"));
const websocket_1 = require("websocket");
const errors_1 = require("../errors");
const MB = 1024 * 1024;
class WsConnection {
    constructor(url) {
        this.url = url;
        this.connected = false;
        this.requests = new Map();
    }
    connect() {
        return new Promise((resolve, reject) => {
            if (this.connected)
                return resolve();
            if (this._ws)
                return reject(new Error('Already connecting'));
            let ws = this._ws = new websocket_1.w3cwebsocket(this.url, undefined, undefined, undefined, undefined, {
                // default: true
                fragmentOutgoingMessages: true,
                // default: 16K (bump, the Node has issues with too many fragments, e.g. on setCode)
                fragmentationThreshold: MB,
                // default: 1MiB (also align with maxReceivedMessageSize)
                maxReceivedFrameSize: 24 * MB,
                // default: 8MB (however Polkadot api.query.staking.erasStakers.entries(356) is over that, 16M is ok there)
                maxReceivedMessageSize: 24 * MB
            });
            ws.onopen = () => {
                if (this._ws !== ws)
                    return;
                this.connected = true;
                resolve();
            };
            ws.onerror = () => {
                if (this._ws !== ws)
                    return;
                let err = new errors_1.RpcConnectionError('Socket error');
                this.close(err);
                reject(err);
            };
            ws.onclose = () => {
                if (this._ws !== ws)
                    return;
                let err = new errors_1.RpcConnectionError('Socket connection terminated');
                this.clear(err);
                reject(err);
            };
            ws.onmessage = event => {
                if (this._ws !== ws)
                    return;
                try {
                    this.onMessage(event.data);
                }
                catch (e) {
                    this.close(e);
                }
            };
        });
    }
    clear(err) {
        for (let handle of this.requests.values()) {
            handle.reject(err);
        }
        this.requests.clear();
        this._ws = undefined;
        this.connected = false;
    }
    close(err) {
        if (this._ws == null)
            return;
        let code;
        let reason;
        if (err instanceof errors_1.RpcProtocolError) {
            code = err.code;
            reason = err.message;
        }
        this._ws.close(code, reason);
        this.clear(err || new errors_1.RpcConnectionError('Connection was closed'));
    }
    onMessage(data) {
        // https://github.com/Luka967/websocket-close-codes
        if (typeof data != 'string') {
            throw new errors_1.RpcProtocolError(1003, 'Received non-text frame');
        }
        let msg;
        try {
            msg = JSON.parse(data);
        }
        catch (e) {
            throw new errors_1.RpcProtocolError(1007, 'Received invalid JSON message');
        }
        if (Array.isArray(msg)) {
            for (let i = 0; i < msg.length; i++) {
                this.handleResponse(msg[i]);
            }
        }
        else {
            this.handleResponse(msg);
        }
    }
    handleResponse(res) {
        // TODO: more strictness, more validation
        let h = this.requests.get(res.id);
        if (h == null) {
            throw new errors_1.RpcProtocolError(1008, `Got response for unknown request ${res.id}`);
        }
        this.requests.delete(res.id);
        h.resolve(res);
    }
    ws() {
        (0, assert_1.default)(this.connected);
        (0, assert_1.default)(this._ws != null);
        return this._ws;
    }
    call(req, timeout) {
        return this.addTimeout(timeout, new Promise((resolve, reject) => {
            this.ws().send(JSON.stringify(req));
            this.requests.set(req.id, { resolve, reject });
        }));
    }
    batchCall(batch, timeout) {
        return this.addTimeout(timeout, new Promise((resolve, reject) => {
            if (batch.length == 0)
                return resolve([]);
            this.ws().send(JSON.stringify(batch));
            let handle = {
                resolve,
                reject,
                results: new Array(batch.length),
                pending: batch.length
            };
            for (let i = 0; i < batch.length; i++) {
                this.requests.set(batch[i].id, new BatchItemHandle(handle, i));
            }
        }));
    }
    addTimeout(ms, promise) {
        if (!ms)
            return promise;
        return new Promise((resolve, reject) => {
            let timer = setTimeout(() => {
                reject(new errors_1.RpcConnectionError(`Request timed out after ${ms} ms`));
                this.close(new errors_1.RpcConnectionError('Closing connection, because one of requests timed out'));
            }, ms);
            promise.finally(() => clearTimeout(timer)).then(resolve, reject);
        });
    }
}
exports.WsConnection = WsConnection;
class BatchItemHandle {
    constructor(handle, idx) {
        this.handle = handle;
        this.idx = idx;
    }
    resolve(res) {
        this.handle.results[this.idx] = res;
        this.handle.pending -= 1;
        if (this.handle.pending == 0) {
            this.handle.resolve(this.handle.results);
        }
    }
    reject(err) {
        this.handle.reject(err);
    }
}
//# sourceMappingURL=ws.js.map