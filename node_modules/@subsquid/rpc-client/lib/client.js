"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = void 0;
const http_client_1 = require("@subsquid/http-client");
const logger_1 = require("@subsquid/logger");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_binary_heap_1 = require("@subsquid/util-internal-binary-heap");
const assert_1 = __importDefault(require("assert"));
const errors_1 = require("./errors");
const rate_1 = require("./rate");
const http_1 = require("./transport/http");
const ws_1 = require("./transport/ws");
class RpcClient {
    constructor(options) {
        this.counter = 0;
        this.queue = new util_internal_binary_heap_1.Heap(byPriority);
        this.rateLimit = Number.MAX_SAFE_INTEGER;
        this.schedulingScheduled = false;
        this.connectionErrorsInRow = 0;
        this.connectionErrors = 0;
        this.requestsServed = 0;
        this.backoffEpoch = 0;
        this.closed = false;
        this.url = trimCredentials(options.url);
        this.con = this.createConnection(options.url);
        this.maxBatchCallSize = options.maxBatchCallSize ?? Number.MAX_SAFE_INTEGER;
        this.capacity = options.capacity ?? 10;
        this.requestTimeout = options.requestTimeout ?? 0;
        this.retryAttempts = options.retryAttempts ?? 0;
        this.retrySchedule = options.retrySchedule ?? [10, 100, 500, 2000, 10000, 20000];
        this.log = options.log === null
            ? undefined
            : options.log || (0, logger_1.createLogger)('sqd:rpc-client', { rpcUrl: this.url });
        if (options.rateLimit) {
            (0, assert_1.default)(Number.isSafeInteger(options.rateLimit));
            (0, assert_1.default)(options.rateLimit > 1);
            this.rate = new rate_1.RateMeter();
            this.rateLimit = options.rateLimit;
            this.maxBatchCallSize = Math.min(this.maxBatchCallSize, Math.max(1, Math.floor(this.rateLimit / 5)));
        }
    }
    createConnection(url) {
        let protocol = new URL(url).protocol;
        switch (protocol) {
            case 'ws:':
            case 'wss:':
                return new ws_1.WsConnection(url);
            case 'http:':
            case 'https:':
                return new http_1.HttpConnection(url, this.log);
            default:
                throw new TypeError(`unsupported protocol: ${protocol}`);
        }
    }
    getMetrics() {
        return {
            url: this.url,
            requestsServed: this.requestsServed,
            connectionErrors: this.connectionErrors
        };
    }
    call(method, params, options) {
        return new Promise((resolve, reject) => {
            let call = {
                id: this.counter += 1,
                jsonrpc: '2.0',
                method,
                params
            };
            if (this.log?.isDebug()) {
                this.log.debug({
                    rpcId: call.id,
                    rpcMethod: call.method,
                    rpcParams: call.params
                }, 'rpc call');
            }
            this.enqueue({
                call,
                priority: options?.priority ?? 0,
                timeout: options?.timeout ?? this.requestTimeout,
                retryAttempts: options?.retryAttempts ?? this.retryAttempts,
                resolve,
                reject,
                validateResult: options?.validateResult
            });
        });
    }
    batchCall(batch, options) {
        return (0, util_internal_1.splitParallelWork)(this.maxBatchCallSize, batch, b => this.batchCallInternal(b, options));
    }
    batchCallInternal(batch, options) {
        if (batch.length == 0)
            return Promise.resolve([]);
        if (batch.length == 1)
            return this.call(batch[0].method, batch[0].params, options).then(res => [res]);
        return new Promise((resolve, reject) => {
            if (batch.length == 0)
                return resolve([]);
            let calls = batch.map(it => {
                return {
                    ...it,
                    id: this.counter += 1,
                    jsonrpc: '2.0'
                };
            });
            if (this.log?.isDebug()) {
                for (let call of calls) {
                    this.log.debug({
                        rpcId: call.id,
                        rpcMethod: call.method,
                        rpcParams: call.params
                    }, 'rpc call');
                }
            }
            this.enqueue({
                call: calls,
                priority: options?.priority ?? 0,
                timeout: options?.timeout ?? this.requestTimeout,
                retryAttempts: options?.retryAttempts ?? this.retryAttempts,
                resolve,
                reject,
                validateResult: options?.validateResult
            });
        });
    }
    enqueue(req) {
        this.assertNotClosed();
        this.queue.push(req);
        this.schedule();
    }
    schedule() {
        if (this.schedulingScheduled || this.closed)
            return;
        if (this.queue.peek() == null || this.capacity <= 0)
            return;
        this.schedulingScheduled = true;
        Promise.resolve().then(() => this.performScheduling());
    }
    delayScheduling() {
        this.schedulingScheduled = true;
        setTimeout(() => this.performScheduling(), 100);
    }
    performScheduling() {
        this.waitForConnection().then(() => {
            if (this.closed)
                return;
            this.schedulingScheduled = false;
            if (this.rate) {
                let now = Date.now();
                let rate = this.rate.getRate(now);
                let rateCapacity = this.rateLimit - rate;
                while (this.capacity > 0 && this.queue.peek()) {
                    let req = this.queue.peek();
                    let size = Array.isArray(req.call) ? req.call.length : 1;
                    rateCapacity -= size;
                    if (rateCapacity < 0)
                        return this.delayScheduling();
                    this.rate.inc(size, now);
                    this.queue.pop();
                    this.send(req);
                }
            }
            else {
                while (this.capacity > 0 && this.queue.peek()) {
                    this.send(this.queue.pop());
                }
            }
        }, err => {
            this.close(err);
        });
    }
    send(req) {
        this.capacity -= 1;
        let backoffEpoch = this.backoffEpoch;
        let promise;
        if (Array.isArray(req.call)) {
            let call = req.call;
            this.log?.debug({ rpcBatchId: [call[0].id, (0, util_internal_1.last)(call).id] }, 'rpc send');
            promise = this.con.batchCall(call, req.timeout).then(res => {
                let result = new Array(res.length);
                for (let i = 0; i < res.length; i++) {
                    result[i] = this.receiveResult(call[i], res[i], req.validateResult);
                }
                return result;
            });
        }
        else {
            let call = req.call;
            this.log?.debug({ rpcId: call.id }, 'rpc send');
            promise = this.con.call(call, req.timeout).then(res => {
                return this.receiveResult(call, res, req.validateResult);
            });
        }
        promise.then(result => {
            this.requestsServed += 1;
            if (this.backoffEpoch == backoffEpoch) {
                this.connectionErrorsInRow = 0;
            }
            req.resolve(result);
        }, err => {
            if (this.closed)
                return req.reject(err);
            if (this.isConnectionError(err)) {
                if (req.retryAttempts > 0) {
                    req.retryAttempts -= 1;
                    this.enqueue(req);
                }
                else {
                    req.reject(err);
                }
                if (this.backoffEpoch == backoffEpoch) {
                    this.backoff(err);
                }
            }
            else {
                req.reject(err);
            }
        }).finally(() => {
            this.capacity += 1;
            this.schedule();
        });
    }
    async waitForConnection() {
        while (true) {
            if (this.getBackoffPause()) {
                await (0, util_internal_1.wait)(this.getBackoffPause());
            }
            if (this.closed)
                return;
            try {
                return await this.con.connect();
            }
            catch (err) {
                if (this.closed)
                    return;
                if (err instanceof errors_1.RpcConnectionError) {
                    this.backoff(err);
                }
                else {
                    throw err;
                }
            }
        }
    }
    backoff(reason) {
        this.log?.warn({ reason: reason.toString() }, 'connection failure');
        this.backoffEpoch += 1;
        this.connectionErrorsInRow += 1;
        this.connectionErrors += 1;
        this.log?.warn(`will pause new requests for ${this.getBackoffPause()}ms`);
    }
    getBackoffPause() {
        if (this.connectionErrorsInRow == 0)
            return 0;
        let idx = Math.min(this.connectionErrorsInRow, this.retrySchedule.length) - 1;
        return this.retrySchedule[idx];
    }
    receiveResult(call, res, validateResult) {
        if (this.log?.isDebug()) {
            this.log.debug({
                rpcId: call.id,
                rpcMethod: call.method,
                rpcParams: call.params,
                rpcResponse: res
            }, 'rpc response');
        }
        try {
            if (res.error) {
                throw new errors_1.RpcError(res.error);
            }
            else if (validateResult) {
                return validateResult(res.result, call);
            }
            else {
                return res.result;
            }
        }
        catch (err) {
            throw (0, util_internal_1.addErrorContext)(err, {
                rpcId: call.id,
                rpcMethod: call.method,
                rpcParams: call.params
            });
        }
    }
    isConnectionError(err) {
        if (err instanceof errors_1.RetryError)
            return true;
        if (isRateLimitError(err))
            return true;
        if (err instanceof errors_1.RpcConnectionError)
            return true;
        if ((0, http_client_1.isHttpConnectionError)(err))
            return true;
        if (err instanceof http_client_1.HttpTimeoutError)
            return true;
        if (err instanceof http_client_1.HttpError) {
            switch (err.response.status) {
                case 429:
                case 502:
                case 503:
                case 504:
                    return true;
                default:
                    return false;
            }
        }
        return false;
    }
    close(err) {
        if (this.closed)
            return;
        this.closed = true;
        this.con.close(err);
        while (this.queue.peek()) { // drain queue
            let req = this.queue.pop();
            req.reject(err || new Error('RpcClient was closed'));
        }
    }
    assertNotClosed() {
        if (this.closed) {
            throw new Error('RpcClient was closed');
        }
    }
}
exports.RpcClient = RpcClient;
function byPriority(a, b) {
    let p = a.priority - b.priority;
    if (p != 0)
        return p;
    return getCallPriority(a) - getCallPriority(b);
}
function getCallPriority(req) {
    if (Array.isArray(req.call)) {
        return req.call[0].id;
    }
    else {
        return req.call.id;
    }
}
function trimCredentials(url) {
    let u = new URL(url);
    u.password = '';
    u.username = '';
    return u.toString();
}
function isRateLimitError(err) {
    return err instanceof errors_1.RpcError && /rate limit/i.test(err.message);
}
//# sourceMappingURL=client.js.map