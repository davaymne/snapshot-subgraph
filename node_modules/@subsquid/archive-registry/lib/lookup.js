"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGenesisHash = exports.getChainInfo = exports.lookupInEVMRegistry = exports.lookupInSubstrateRegistry = exports.lookupArchive = void 0;
const assert_1 = __importDefault(require("assert"));
const sync_fetch_1 = __importDefault(require("sync-fetch"));
const registry_1 = require("./registry");
function lookupArchive(network, opts) {
    if (!opts) {
        opts = {};
    }
    let registrySubstrate = (0, registry_1.archivesRegistrySubstrate)();
    let registryEvm = (0, registry_1.archivesRegistryEVM)();
    if (!opts.type) {
        let isSubstrateNetwork = registrySubstrate.archives.some((a) => a.network === network);
        let isEvmNetwork = registryEvm.archives.some((a) => a.network === network);
        if (isEvmNetwork && isSubstrateNetwork) {
            throw new Error(`There are multiple networks with name ${network}. Provide network type to disambiguate.`);
        }
        else if (isEvmNetwork) {
            opts.type = 'EVM';
        }
        else if (isSubstrateNetwork) {
            opts.type = 'Substrate';
        }
        else {
            throw new Error(`Failed to lookup a matching archive. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
        }
    }
    switch (opts.type) {
        case 'Substrate':
            return lookupInSubstrateRegistry(network, registrySubstrate, {
                release: 'FireSquid',
                ...opts,
            })[0].dataSourceUrl;
        case 'EVM':
            return lookupInEVMRegistry(network, registryEvm, {
                release: 'ArrowSquid',
                ...opts,
            })[0].dataSourceUrl;
        default:
            throw new Error(`Archive registry type must be value from RegistryTypes ("Substrate", "EVM", ...)`);
    }
}
exports.lookupArchive = lookupArchive;
/**
 * Lookup providers matching the optional filtering criteria in a given Substrate registry
 *
 * @param network network name for lookup
 * @param opts.genesis network genesis hex string (must start with "0x...")
 * @param opts.image archive image name
 * @param opts.ingest archive image name
 * @param opts.gateway archive gateway image
 *
 * @returns A list of matching providers
 * @throws If none matching archive is found or if there's ambiguity in choosing the network
 */
function lookupInSubstrateRegistry(network, registry, opts) {
    let archives = registry.archives.filter((a) => a.network.toLowerCase() === network.toLowerCase());
    if (opts?.genesis) {
        archives = archives.filter((a) => a.genesisHash?.toLowerCase() === opts.genesis?.toLowerCase());
    }
    if (archives.length === 0) {
        throw new Error(`Failed to lookup a matching archive. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    if (archives.length > 1) {
        throw new Error(`There are multiple networks with name ${network}. \
Provide the genesis hash to disambiguate.`);
    }
    let matched = archives[0].providers;
    if (opts?.image) {
        matched = matched.filter((p) => p.image === opts.image);
    }
    if (opts?.ingest) {
        matched = matched.filter((p) => p.ingest === opts.ingest);
    }
    if (opts?.gateway) {
        matched = matched.filter((p) => p.gateway === opts.gateway);
    }
    if (opts?.release) {
        matched = matched.filter((p) => p.release === opts.release);
    }
    if (matched.length === 0) {
        throw new Error(`Failed to lookup a matching archive. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    return matched;
}
exports.lookupInSubstrateRegistry = lookupInSubstrateRegistry;
/**
 * Lookup Subsquid Substrate Archive endpoint by network name
 *
 * @param network network name for lookup
 * @param opts.ingester archive ingester name
 * @param opts.worker archive worker image
 * @param opts.release archive release (for example Stage version)
 *
 * @returns Archive endpoint url matching the filter
 * @throws If none matching archive is found or if there's ambiguity in choosing the network
 */
function lookupInEVMRegistry(network, registry, opts) {
    let archives = registry.archives.filter((a) => a.network.toLowerCase() === network.toLowerCase());
    if (archives.length > 1) {
        throw new Error(`There are multiple networks with name ${network}. \
Provide the genesis hash to disambiguate.`);
    }
    let matched = archives[0].providers;
    if (opts?.release) {
        matched = matched.filter((p) => p.release === opts.release);
    }
    if (matched.length === 0) {
        throw new Error(`Failed to lookup a matching archive. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    return matched;
}
exports.lookupInEVMRegistry = lookupInEVMRegistry;
/**
 * Get parachain information by its name
 *
 * @param network Network name
 * @returns Chain info incluing genesis hash, token symbols, parachainId if relevent, etc
 */
function getChainInfo(network, genesis) {
    let matched = (0, registry_1.networkRegistrySubstrate)().networks.filter((n) => n.name.toLowerCase() === network.toLowerCase());
    if (genesis) {
        matched = matched.filter((a) => a.genesisHash?.toLowerCase() === genesis.toLowerCase());
    }
    if (matched.length === 0) {
        throw new Error(`Failed to get info on ${network}. \
Please consider submitting a PR to subsquid/archive-registry github repo to extend the registry`);
    }
    if (matched.length > 1) {
        throw new Error(`There are multiple networks with name ${network}. \
Provide genesis hash option to prevent ambiguity.`);
    }
    return matched[0];
}
exports.getChainInfo = getChainInfo;
function getGenesisHash(endpoint) {
    const query = `
    query {
        blocks(where: {height_eq: 0}, limit: 1) {
            hash
        }
    }
    `;
    const result = archiveRequest(endpoint, query);
    return result.blocks[0].hash;
}
exports.getGenesisHash = getGenesisHash;
function archiveRequest(endpoint, query) {
    let response = (0, sync_fetch_1.default)(endpoint, {
        method: 'POST',
        body: JSON.stringify({ query }),
        headers: {
            'content-type': 'application/json',
            accept: 'application/json',
            'accept-encoding': 'gzip, br',
        },
        timeout: 5000, // 5 second timeout
    });
    if (!response.ok) {
        let body = response.text();
        throw new Error(`Got http ${response.status}${body ? `, body: ${body}` : ''}`);
    }
    let result = response.json();
    if (result.errors?.length) {
        throw new Error(`GraphQL error: ${result.errors[0].message}`);
    }
    (0, assert_1.default)(result.data != null);
    return result.data;
}
//# sourceMappingURL=lookup.js.map