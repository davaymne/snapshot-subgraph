"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBatchProcessor = void 0;
const http_client_1 = require("@subsquid/http-client");
const logger_1 = require("@subsquid/logger");
const rpc_client_1 = require("@subsquid/rpc-client");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_archive_client_1 = require("@subsquid/util-internal-archive-client");
const util_internal_processor_tools_1 = require("@subsquid/util-internal-processor-tools");
const assert_1 = __importDefault(require("assert"));
const client_1 = require("./ds-archive/client");
const client_2 = require("./ds-rpc/client");
/**
 * Provides methods to configure and launch data processing.
 */
class EvmBatchProcessor {
    constructor() {
        this.requests = [];
        this.running = false;
    }
    add(request, range) {
        this.requests.push({
            range: range || { from: 0 },
            request
        });
    }
    /**
     * Configure a set of fetched fields
     */
    setFields(fields) {
        this.assertNotRunning();
        this.fields = fields;
        return this;
    }
    addLog(options) {
        this.assertNotRunning();
        this.add({
            logs: [mapRequest(options)]
        }, options.range);
        return this;
    }
    addTransaction(options) {
        this.assertNotRunning();
        this.add({
            transactions: [mapRequest(options)]
        }, options.range);
        return this;
    }
    addTrace(options) {
        this.assertNotRunning();
        this.add({
            traces: [mapRequest(options)]
        }, options.range);
        return this;
    }
    addStateDiff(options) {
        this.assertNotRunning();
        this.add({
            stateDiffs: [mapRequest(options)]
        }, options.range);
        return this;
    }
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port) {
        this.assertNotRunning();
        this.getPrometheusServer().setPort(port);
        return this;
    }
    /**
     * By default, the processor will fetch only blocks
     * which contain requested items. This method
     * modifies such behaviour to fetch all chain blocks.
     *
     * Optionally a range of blocks can be specified
     * for which the setting should be effective.
     */
    includeAllBlocks(range) {
        this.assertNotRunning();
        this.add({ includeAllBlocks: true }, range);
        return this;
    }
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     */
    setBlockRange(range) {
        this.assertNotRunning();
        this.blockRange = range;
        return this;
    }
    /**
     * Sets blockchain data source.
     *
     * @example
     * processor.setDataSource({
     *     archive: 'https://v2.archive.subsquid.io/network/ethereum-mainnet',
     *     chain: 'https://eth-mainnet.public.blastapi.io'
     * })
     */
    setDataSource(src) {
        this.assertNotRunning();
        this.src = src;
        return this;
    }
    setFinalityConfirmation(nBlocks) {
        this.assertNotRunning();
        this.finalityConfirmation = nBlocks;
        return this;
    }
    setChainPollInterval(ms) {
        (0, assert_1.default)(ms >= 0);
        this.assertNotRunning();
        this.chainPollInterval = ms;
        return this;
    }
    preferTraceApi(yes) {
        this.assertNotRunning();
        this._preferTraceApi = yes !== false;
        return this;
    }
    useDebugApiForStateDiffs(yes) {
        this.assertNotRunning();
        this._useDebugApiForStateDiffs = yes !== false;
        return this;
    }
    useArchiveOnly(yes) {
        this.assertNotRunning();
        this._useArchiveOnly = yes !== false;
        return this;
    }
    assertNotRunning() {
        if (this.running) {
            throw new Error('Settings modifications are not allowed after start of processing');
        }
    }
    getLogger() {
        return (0, logger_1.createLogger)('sqd:processor');
    }
    getSquidId() {
        return (0, util_internal_processor_tools_1.getOrGenerateSquidId)();
    }
    getPrometheusServer() {
        return new util_internal_processor_tools_1.PrometheusServer();
    }
    getDataSource() {
        if (this.src == null) {
            throw new Error('use .setDataSource() to specify archive and/or chain RPC endpoint');
        }
        return this.src;
    }
    getChainRpcClient() {
        let options = this.src?.chain;
        if (options == null) {
            throw new Error(`use .setDataSource() to specify chain RPC endpoint`);
        }
        if (typeof options == 'string') {
            options = { url: options };
        }
        let client = new rpc_client_1.RpcClient({
            url: options.url,
            maxBatchCallSize: options.maxBatchCallSize ?? 100,
            requestTimeout: options.requestTimeout ?? 30000,
            capacity: options.capacity ?? 10,
            rateLimit: options.rateLimit,
            retryAttempts: Number.MAX_SAFE_INTEGER,
            log: this.getLogger().child('rpc', { rpcUrl: options.url })
        });
        this.getPrometheusServer().addChainRpcMetrics(() => client.getMetrics());
        return client;
    }
    getChain() {
        let self = this;
        return {
            get client() {
                return self.getChainRpcClient();
            }
        };
    }
    getHotDataSource() {
        if (this.finalityConfirmation == null) {
            throw new Error(`use .setFinalityConfirmation() to specify number of children required to confirm block's finality`);
        }
        return new client_2.EvmRpcDataSource({
            rpc: this.getChainRpcClient(),
            finalityConfirmation: this.finalityConfirmation,
            preferTraceApi: this._preferTraceApi,
            useDebugApiForStateDiffs: this._useDebugApiForStateDiffs,
            pollInterval: this.chainPollInterval,
            log: this.getLogger().child('rpc', { rpcUrl: this.getChainRpcClient().url })
        });
    }
    getArchiveDataSource() {
        let archive = (0, util_internal_1.assertNotNull)(this.getDataSource().archive);
        if (typeof archive == 'string') {
            archive = { url: archive };
        }
        let log = this.getLogger().child('archive');
        let http = new http_client_1.HttpClient({
            headers: {
                'x-squid-id': this.getSquidId()
            },
            agent: new http_client_1.HttpAgent({
                keepAlive: true
            }),
            log: log.child('http')
        });
        return new client_1.EvmArchive(new util_internal_archive_client_1.ArchiveClient({
            http,
            log,
            url: archive.url,
            queryTimeout: archive.requestTimeout
        }));
    }
    getBatchRequests() {
        let requests = (0, util_internal_processor_tools_1.mergeRangeRequests)(this.requests, function merge(a, b) {
            let res = {};
            if (a.includeAllBlocks || b.includeAllBlocks) {
                res.includeAllBlocks = true;
            }
            res.transactions = concatRequestLists(a.transactions, b.transactions);
            res.logs = concatRequestLists(a.logs, b.logs);
            res.traces = concatRequestLists(a.traces, b.traces);
            res.stateDiffs = concatRequestLists(a.stateDiffs, b.stateDiffs);
            return res;
        });
        if (this.fields) {
            requests.forEach(req => {
                req.request.fields = this.fields;
            });
        }
        return (0, util_internal_processor_tools_1.applyRangeBound)(requests, this.blockRange);
    }
    /**
     * Run data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     *
     * @param database - database is responsible for providing storage to data handlers
     * and persisting mapping progress and status.
     *
     * @param handler - The data handler, see {@link BatchContext} for an API available to the handler.
     */
    run(database, handler) {
        this.assertNotRunning();
        this.running = true;
        let log = this.getLogger();
        (0, util_internal_1.runProgram)(async () => {
            let src = this.getDataSource();
            let chain = this.getChain();
            let mappingLog = log.child('mapping');
            if (src.archive == null && this._useArchiveOnly) {
                throw new Error('Archive URL is required when .useArchiveOnly() flag is set');
            }
            return new util_internal_processor_tools_1.Runner({
                database,
                requests: this.getBatchRequests(),
                archive: src.archive ? this.getArchiveDataSource() : undefined,
                hotDataSource: src.chain && !this._useArchiveOnly ? this.getHotDataSource() : undefined,
                allBlocksAreFinal: this.finalityConfirmation === 0,
                prometheus: this.getPrometheusServer(),
                log,
                process(store, batch) {
                    return handler({
                        _chain: chain,
                        log: mappingLog,
                        store,
                        blocks: batch.blocks,
                        isHead: batch.isHead
                    });
                }
            }).run();
        }, err => log.fatal(err));
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", logger_1.Logger)
], EvmBatchProcessor.prototype, "getLogger", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], EvmBatchProcessor.prototype, "getSquidId", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", util_internal_processor_tools_1.PrometheusServer)
], EvmBatchProcessor.prototype, "getPrometheusServer", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", rpc_client_1.RpcClient)
], EvmBatchProcessor.prototype, "getChainRpcClient", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], EvmBatchProcessor.prototype, "getChain", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", client_2.EvmRpcDataSource)
], EvmBatchProcessor.prototype, "getHotDataSource", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", client_1.EvmArchive)
], EvmBatchProcessor.prototype, "getArchiveDataSource", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], EvmBatchProcessor.prototype, "getBatchRequests", null);
exports.EvmBatchProcessor = EvmBatchProcessor;
function mapRequest(options) {
    let { range, ...req } = options;
    for (let key in req) {
        let val = req[key];
        if (Array.isArray(val)) {
            req[key] = val.map(s => s.toLowerCase());
        }
    }
    return req;
}
function concatRequestLists(a, b) {
    let result = [];
    if (a) {
        result.push(...a);
    }
    if (b) {
        result.push(...b);
    }
    return result.length == 0 ? undefined : result;
}
//# sourceMappingURL=processor.js.map