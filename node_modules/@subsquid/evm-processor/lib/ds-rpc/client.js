"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmRpcDataSource = void 0;
const rpc_client_1 = require("@subsquid/rpc-client");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_processor_tools_1 = require("@subsquid/util-internal-processor-tools");
const assert_1 = __importDefault(require("assert"));
const mapping_1 = require("../ds-archive/mapping");
const mapping_2 = require("./mapping");
class EvmRpcDataSource {
    constructor(options) {
        this.rpc = options.rpc;
        this.finalityConfirmation = options.finalityConfirmation;
        this.strideSize = options.strideSize ?? 10;
        this.pollInterval = options.pollInterval ?? 1000;
        this.useDebugApiForStateDiffs = options.useDebugApiForStateDiffs ?? false;
        this.preferTraceApi = options.preferTraceApi ?? false;
        this.log = options.log;
    }
    async getFinalizedHeight() {
        let height = await this.getHeight();
        return Math.max(0, height - this.finalityConfirmation);
    }
    async getHeight() {
        let height = await this.rpc.call('eth_blockNumber');
        return (0, mapping_2.qty2Int)(height);
    }
    async getBlockHash(height) {
        let block = await this.rpc.call('eth_getBlockByNumber', [(0, mapping_2.toQty)(height), false]);
        return block.hash;
    }
    getGenesisHash() {
        return this.getBlockHash(0);
    }
    async *getHotBlocks(requests, state) {
        let requestsTracker = new util_internal_processor_tools_1.RequestsTracker(requests.map(toRpcBatchRequest));
        let heightTracker = new util_internal_processor_tools_1.PollingHeightTracker(() => this.getHeight(), this.pollInterval);
        let nav = new util_internal_processor_tools_1.ForkNavigator(state, ref => {
            let height = (0, util_internal_1.assertNotNull)(ref.height);
            let req = requestsTracker.getRequestAt(height);
            return this.fetchHotBlock({ height, hash: ref.hash }, req);
        }, block => block.header);
        for await (let top of (0, util_internal_processor_tools_1.getHeightUpdates)(heightTracker, nav.getHeight() + 1)) {
            let finalized = Math.max(top - this.finalityConfirmation, 0);
            for (let number = nav.getHeight() + 1; number <= top; number++) {
                let update = await this.getHotUpdate(nav, number, finalized);
                yield update;
                if (!requestsTracker.hasRequestsAfter(update.finalizedHead.height))
                    return;
            }
        }
    }
    async getHotUpdate(nav, blockHeight, finalizedHeight) {
        let retries = 0;
        while (true) {
            try {
                return await nav.move({
                    best: blockHeight,
                    finalized: Math.min(blockHeight, finalizedHeight)
                });
            }
            catch (err) {
                if (isConsistencyError(err) && retries < 10) {
                    retries += 1;
                    if (retries > 2) {
                        this.log?.warn(err.message);
                    }
                    await (0, util_internal_1.wait)(200 * retries);
                }
                else {
                    throw err;
                }
            }
        }
    }
    async fetchHotBlock(ref, req) {
        let withTransactions = !!req?.transactions;
        let block0;
        if (ref.hash) {
            block0 = await this.rpc.call('eth_getBlockByHash', [ref.hash, withTransactions]);
        }
        else {
            block0 = await this.rpc.call('eth_getBlockByNumber', [(0, mapping_2.toQty)(ref.height), withTransactions]);
        }
        if (block0 == null) {
            throw new ConsistencyError(ref);
        }
        let processed = await this.processBlocks([block0], req, 0);
        return processed[0];
    }
    getFinalizedBlocks(requests, stopOnHead) {
        let heightTracker = new util_internal_processor_tools_1.PollingHeightTracker(() => this.getFinalizedHeight(), this.pollInterval);
        return (0, util_internal_1.concurrentMap)(5, (0, util_internal_processor_tools_1.generateFetchStrides)({
            requests: requests.map(toRpcBatchRequest),
            heightTracker,
            strideSize: this.strideSize,
            stopOnHead
        }), async (s) => {
            let blocks0 = await this.getStride0(s);
            let blocks = await this.processBlocks(blocks0, s.request);
            return {
                blocks,
                isHead: s.range.to >= heightTracker.getLastHeight()
            };
        });
    }
    async getStride0(s) {
        let call = [];
        for (let i = s.range.from; i <= s.range.to; i++) {
            call.push({
                method: 'eth_getBlockByNumber',
                params: [(0, mapping_2.toQty)(i), s.request.transactions]
            });
        }
        let blocks = await this.rpc.batchCall(call, {
            priority: s.range.from,
            validateResult: nonNull
        });
        for (let i = 1; i < blocks.length; i++) {
            assert_1.default.strictEqual(blocks[i - 1].hash, blocks[i].parentHash, 'perhaps finality confirmation was not large enough');
        }
        return blocks;
    }
    async processBlocks(blocks, request, finalizedHeight) {
        if (blocks.length == 0)
            return [];
        let req = request ?? (0, mapping_2.toRpcDataRequest)();
        await this.fetchRequestedData(blocks, req, finalizedHeight);
        return blocks.map(b => (0, mapping_2.mapBlock)(b, !!req.transactionList));
    }
    async fetchRequestedData(blocks, req, finalizedHeight) {
        let subtasks = [];
        if (req.logs && !req.receipts) {
            subtasks.push(catching(this.fetchLogs(blocks)));
        }
        if (req.receipts) {
            let byBlockMethod = await this.getBlockReceiptsMethod();
            if (byBlockMethod) {
                subtasks.push(catching(this.fetchReceiptsByBlock(blocks, byBlockMethod)));
            }
            else {
                subtasks.push(catching(this.fetchReceiptsByTx(blocks)));
            }
        }
        if (req.traces || req.stateDiffs) {
            let isArbitrumOne = await this.getGenesisHash() === '0x7ee576b35482195fc49205cec9af72ce14f003b9ae69f6ba0faef4514be8b442';
            if (isArbitrumOne) {
                subtasks.push(this.fetchArbitrumOneTraces(blocks, req));
            }
            else {
                subtasks.push(this.fetchTraces(blocks, req, finalizedHeight ?? Number.MAX_SAFE_INTEGER));
            }
        }
        await Promise.all(subtasks);
    }
    async fetchLogs(blocks) {
        let logs = await this.requestLogs((0, mapping_2.getBlockHeight)(blocks[0]), (0, mapping_2.getBlockHeight)((0, util_internal_1.last)(blocks)));
        let logsByBlock = (0, util_internal_1.groupBy)(logs, log => log.blockHash);
        for (let block of blocks) {
            let logs = logsByBlock.get(block.hash) || [];
            if (logs.length == 0 && block.logsBloom !== mapping_1.NO_LOGS_BLOOM) {
                throw new ConsistencyError(block);
            }
            else {
                block._logs = logs;
            }
        }
    }
    async requestLogs(from, to) {
        return this.rpc.call('eth_getLogs', [{
                fromBlock: (0, mapping_2.toQty)(from),
                toBlock: (0, mapping_2.toQty)(to)
            }], {
            priority: from
        }).catch(async (err) => {
            let range = toTryAnotherRangeError(err);
            if (range && range.from == from && from <= range.to && range.to < to) {
                let result = await Promise.all([
                    this.requestLogs(range.from, range.to),
                    this.requestLogs(range.to + 1, to)
                ]);
                return result[0].concat(result[1]);
            }
            else {
                throw err;
            }
        });
    }
    async fetchReceiptsByBlock(blocks, method) {
        let call = blocks.map(block => {
            if (method == 'eth_getBlockReceipts') {
                return {
                    method,
                    params: [block.number]
                };
            }
            else {
                return {
                    method,
                    params: [{ blockHash: block.hash }]
                };
            }
        });
        let results = await this.rpc.batchCall(call, {
            priority: (0, mapping_2.getBlockHeight)(blocks[0]),
            validateResult: nonNull
        });
        for (let i = 0; i < blocks.length; i++) {
            let block = blocks[i];
            let receipts = results[i];
            if (block.transactions.length !== receipts.length)
                throw new ConsistencyError(block);
            for (let receipt of receipts) {
                if (receipt.blockHash !== block.hash)
                    throw new ConsistencyError(block);
            }
            block._receipts = receipts;
        }
    }
    async getBlockReceiptsMethod() {
        let alchemy = await this.rpc.call('alchemy_getTransactionReceipts', [{ blockNumber: '0x0' }]).then(res => Array.isArray(res), () => false);
        if (alchemy)
            return 'alchemy_getTransactionReceipts';
        let eth = await this.rpc.call('eth_getBlockReceipts', ['latest']).then(res => Array.isArray(res), () => false);
        if (eth)
            return 'eth_getBlockReceipts';
        return undefined;
    }
    async fetchReceiptsByTx(blocks) {
        let call = [];
        for (let block of blocks) {
            for (let tx of block.transactions) {
                call.push({
                    method: 'eth_getTransactionReceipt',
                    params: [(0, mapping_2.getTxHash)(tx)]
                });
            }
        }
        let receipts = await this.rpc.batchCall(call, {
            priority: (0, mapping_2.getBlockHeight)(blocks[0])
        });
        let receiptsByBlock = (0, util_internal_1.groupBy)(receipts.filter(r => r != null), r => r.blockHash);
        for (let block of blocks) {
            let rs = receiptsByBlock.get(block.hash) || [];
            if (rs.length !== block.transactions.length) {
                throw new ConsistencyError(block);
            }
            block._receipts = rs;
        }
    }
    fetchTraces(blocks, req, finalizedHeight) {
        let tasks = [];
        let replayTracers = [];
        if (req.stateDiffs) {
            if (finalizedHeight < (0, mapping_2.getBlockHeight)((0, util_internal_1.last)(blocks)) || this.useDebugApiForStateDiffs) {
                tasks.push(catching(this.fetchDebugStateDiffs(blocks)));
            }
            else {
                replayTracers.push('stateDiff');
            }
        }
        if (req.traces) {
            if (this.preferTraceApi) {
                if (finalizedHeight < (0, mapping_2.getBlockHeight)((0, util_internal_1.last)(blocks)) || replayTracers.length == 0) {
                    tasks.push(catching(this.fetchTraceBlock(blocks)));
                }
                else {
                    replayTracers.push('trace');
                }
            }
            else {
                tasks.push(catching(this.fetchDebugFrames(blocks)));
            }
        }
        if (replayTracers.length) {
            tasks.push(catching(this.fetchReplays(blocks, replayTracers)));
        }
        return Promise.all(tasks).then();
    }
    async fetchReplays(blocks, tracers, method = 'trace_replayBlockTransactions') {
        if (tracers.length == 0)
            return;
        let call = blocks.map(block => ({
            method,
            params: [block.number, tracers]
        }));
        let replaysByBlock = await this.rpc.batchCall(call, {
            priority: (0, mapping_2.getBlockHeight)(blocks[0])
        });
        for (let i = 0; i < blocks.length; i++) {
            let block = blocks[i];
            let replays = replaysByBlock[i];
            let txs = new Set(block.transactions.map(mapping_2.getTxHash));
            for (let rep of replays) {
                if (!rep.transactionHash) { // FIXME: Who behaves like that? Arbitrum?
                    let txHash = undefined;
                    for (let frame of rep.trace || []) {
                        (0, assert_1.default)(txHash == null || txHash === frame.transactionHash);
                        txHash = txHash || frame.transactionHash;
                    }
                    (0, assert_1.default)(txHash, "Can't match transaction replay with its transaction");
                    rep.transactionHash = txHash;
                }
                // Sometimes replays might be missing. FIXME: when?
                if (!txs.has(rep.transactionHash)) {
                    throw new ConsistencyError(block);
                }
            }
            block._traceReplays = replays;
        }
    }
    async fetchTraceBlock(blocks) {
        let call = blocks.map(block => ({
            method: 'trace_block',
            params: [block.number]
        }));
        let results = await this.rpc.batchCall(call, {
            priority: (0, mapping_2.getBlockHeight)(blocks[0])
        });
        for (let i = 0; i < blocks.length; i++) {
            let block = blocks[i];
            let frames = results[i];
            if (frames.length == 0) {
                if (block.transactions.length > 0)
                    throw new ConsistencyError(block);
            }
            else {
                for (let frame of frames) {
                    if (frame.blockHash !== block.hash)
                        throw new ConsistencyError(block);
                }
                block._traceReplays = [];
                let byTx = (0, util_internal_1.groupBy)(frames, f => f.transactionHash);
                for (let [transactionHash, txFrames] of byTx.entries()) {
                    if (transactionHash) {
                        block._traceReplays.push({
                            transactionHash,
                            trace: txFrames
                        });
                    }
                }
            }
        }
    }
    async fetchDebugFrames(blocks) {
        let traceConfig = {
            tracer: 'callTracer',
            tracerConfig: {
                onlyTopCall: false,
                withLog: false // will study log <-> frame matching problem later
            }
        };
        let call = blocks.map(block => ({
            method: 'debug_traceBlockByHash',
            params: [block.hash, traceConfig]
        }));
        let results = await this.rpc.batchCall(call, {
            priority: (0, mapping_2.getBlockHeight)(blocks[0])
        });
        for (let i = 0; i < blocks.length; i++) {
            let block = blocks[i];
            let frames = results[i];
            (0, assert_1.default)(block.transactions.length === frames.length);
            // Moonbeam quirk
            for (let j = 0; j < frames.length; j++) {
                if (!frames[j].result) {
                    frames[j] = { result: frames[j] };
                }
            }
            block._debugFrames = frames;
        }
    }
    async fetchDebugStateDiffs(blocks) {
        let traceConfig = {
            tracer: 'prestateTracer',
            tracerConfig: {
                onlyTopCall: false,
                diffMode: true
            }
        };
        let call = blocks.map(block => ({
            method: 'debug_traceBlockByHash',
            params: [block.hash, traceConfig]
        }));
        let results = await this.rpc.batchCall(call, {
            priority: (0, mapping_2.getBlockHeight)(blocks[0])
        });
        for (let i = 0; i < blocks.length; i++) {
            let block = blocks[i];
            let diffs = results[i];
            (0, assert_1.default)(block.transactions.length === diffs.length);
            block._debugStateDiffs = diffs;
        }
    }
    async fetchArbitrumOneTraces(blocks, req) {
        if (req.stateDiffs) {
            throw new Error('State diffs are not supported on Arbitrum One');
        }
        if (!req.traces)
            return;
        let arbBlocks = blocks.filter(b => (0, mapping_2.getBlockHeight)(b) <= 22207815);
        let debugBlocks = blocks.filter(b => (0, mapping_2.getBlockHeight)(b) >= 22207818);
        if (arbBlocks.length) {
            await this.fetchReplays(arbBlocks, ['trace'], 'arbtrace_replayBlockTransactions');
        }
        if (debugBlocks.length) {
            await this.fetchDebugFrames(debugBlocks);
        }
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], EvmRpcDataSource.prototype, "getGenesisHash", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], EvmRpcDataSource.prototype, "getBlockReceiptsMethod", null);
exports.EvmRpcDataSource = EvmRpcDataSource;
class ConsistencyError extends Error {
    constructor(block) {
        let name = typeof block == 'object' ? (0, mapping_2.getBlockName)(block) : block;
        super(`Seems like the chain node navigated to another branch while we were fetching block ${name} or lost it`);
    }
}
function toRpcBatchRequest(request) {
    return {
        range: request.range,
        request: (0, mapping_2.toRpcDataRequest)(request.request)
    };
}
function isConsistencyError(err) {
    if (err instanceof ConsistencyError)
        return true;
    if (err instanceof rpc_client_1.RpcError) {
        // eth_gelBlockByNumber on Moonbeam reacts like that when block is not present
        if (/Expect block number from id/i.test(err.message))
            return true;
    }
    return false;
}
function catching(promise) {
    // prevent unhandled promise rejection crashes
    promise.catch(() => { });
    return promise;
}
class UnexpectedResponse extends rpc_client_1.RetryError {
    get name() {
        return 'UnexpectedResponse';
    }
}
function nonNull(result, req) {
    if (result == null)
        throw new UnexpectedResponse(`Result of call ${JSON.stringify(req)} was null. Perhaps, you should find a better endpoint.`);
    return result;
}
function toTryAnotherRangeError(err) {
    if (!(err instanceof rpc_client_1.RpcError))
        return;
    let m = /Try with this block range \[(0x[0-9a-f]+), (0x[0-9a-f]+)]/i.exec(err.message);
    if (m == null)
        return;
    return {
        from: (0, mapping_2.qty2Int)(m[1]),
        to: (0, mapping_2.qty2Int)(m[2])
    };
}
//# sourceMappingURL=client.js.map