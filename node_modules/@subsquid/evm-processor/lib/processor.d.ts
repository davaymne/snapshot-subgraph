import { Logger } from '@subsquid/logger';
import { Database, Range } from '@subsquid/util-internal-processor-tools';
import { Chain } from './interfaces/chain';
import { BlockData, FieldSelection } from './interfaces/data';
import { LogRequest, StateDiffRequest, TraceRequest, TransactionRequest } from './interfaces/data-request';
export type DataSource = ArchiveDataSource | ChainDataSource;
type ChainRpc = string | {
    url: string;
    capacity?: number;
    rateLimit?: number;
    requestTimeout?: number;
    maxBatchCallSize?: number;
};
type ArchiveConnection = string | {
    url: string;
    requestTimeout?: number;
};
interface ArchiveDataSource {
    /**
     * Subsquid evm archive endpoint URL
     */
    archive: ArchiveConnection;
    /**
     * Chain node RPC endpoint URL
     */
    chain?: ChainRpc;
}
interface ChainDataSource {
    archive?: undefined;
    /**
     * Chain node RPC endpoint URL
     */
    chain: ChainRpc;
}
interface BlockRange {
    /**
     * Block range
     */
    range?: Range;
}
export interface DataHandlerContext<Store, F extends FieldSelection = {}> {
    _chain: Chain;
    log: Logger;
    store: Store;
    blocks: BlockData<F>[];
    isHead: boolean;
}
export type EvmBatchProcessorFields<T> = T extends EvmBatchProcessor<infer F> ? F : never;
/**
 * Provides methods to configure and launch data processing.
 */
export declare class EvmBatchProcessor<F extends FieldSelection = {}> {
    private requests;
    private src?;
    private blockRange?;
    private fields?;
    private finalityConfirmation?;
    private _preferTraceApi?;
    private _useDebugApiForStateDiffs?;
    private _useArchiveOnly?;
    private chainPollInterval?;
    private running;
    private add;
    /**
     * Configure a set of fetched fields
     */
    setFields<T extends FieldSelection>(fields: T): EvmBatchProcessor<T>;
    addLog(options: LogRequest & BlockRange): this;
    addTransaction(options: TransactionRequest & BlockRange): this;
    addTrace(options: TraceRequest & BlockRange): this;
    addStateDiff(options: StateDiffRequest & BlockRange): this;
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port: number | string): this;
    /**
     * By default, the processor will fetch only blocks
     * which contain requested items. This method
     * modifies such behaviour to fetch all chain blocks.
     *
     * Optionally a range of blocks can be specified
     * for which the setting should be effective.
     */
    includeAllBlocks(range?: Range): this;
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     */
    setBlockRange(range?: Range): this;
    /**
     * Sets blockchain data source.
     *
     * @example
     * processor.setDataSource({
     *     archive: 'https://v2.archive.subsquid.io/network/ethereum-mainnet',
     *     chain: 'https://eth-mainnet.public.blastapi.io'
     * })
     */
    setDataSource(src: DataSource): this;
    setFinalityConfirmation(nBlocks: number): this;
    setChainPollInterval(ms: number): this;
    preferTraceApi(yes?: boolean): this;
    useDebugApiForStateDiffs(yes?: boolean): this;
    useArchiveOnly(yes?: boolean): this;
    private assertNotRunning;
    private getLogger;
    private getSquidId;
    private getPrometheusServer;
    private getDataSource;
    private getChainRpcClient;
    private getChain;
    private getHotDataSource;
    private getArchiveDataSource;
    private getBatchRequests;
    /**
     * Run data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     *
     * @param database - database is responsible for providing storage to data handlers
     * and persisting mapping progress and status.
     *
     * @param handler - The data handler, see {@link BatchContext} for an API available to the handler.
     */
    run<Store>(database: Database<Store>, handler: (ctx: DataHandlerContext<Store, F>) => Promise<void>): void;
}
export {};
//# sourceMappingURL=processor.d.ts.map