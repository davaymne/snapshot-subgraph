"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withDefaultFields = exports.mapGatewayBlock = exports.NO_LOGS_BLOOM = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const data_1 = require("../interfaces/data");
const util_1 = require("../util");
exports.NO_LOGS_BLOOM = '0x' + Buffer.alloc(256).toString('hex');
function mapGatewayBlock(src) {
    try {
        return tryMapGatewayBlock(src);
    }
    catch (e) {
        throw (0, util_internal_1.addErrorContext)(e, {
            blockHeight: src.header.number,
            blockHash: src.header.hash
        });
    }
}
exports.mapGatewayBlock = mapGatewayBlock;
function tryMapGatewayBlock(src) {
    let header = mapBlockHeader(src.header);
    let block = {
        header,
        transactions: [],
        logs: [],
        traces: [],
        stateDiffs: []
    };
    let txIndex = new Map();
    for (let go of src.transactions || []) {
        let transaction = mapTransaction(header, go);
        txIndex.set(transaction.transactionIndex, transaction);
        block.transactions.push(transaction);
    }
    for (let go of src.logs || []) {
        let log = {
            id: (0, util_1.formatId)(header.height, header.hash, go.logIndex),
            ...go,
            block: header
        };
        let transaction = txIndex.get(log.transactionIndex);
        if (transaction) {
            log.transaction = transaction;
        }
        block.logs.push(log);
    }
    for (let go of src.traces || []) {
        let trace = mapTrace(go);
        trace.block = header;
        let transaction = txIndex.get(go.transactionIndex);
        if (transaction) {
            trace.transaction = transaction;
        }
        block.traces.push(trace);
    }
    for (let go of src.stateDiffs || []) {
        let diff = {
            ...go,
            block: header
        };
        let transaction = txIndex.get(go.transactionIndex);
        if (transaction) {
            diff.transaction = transaction;
        }
        block.stateDiffs.push(diff);
    }
    return block;
}
function mapBlockHeader(src) {
    let header = {
        id: (0, util_1.formatId)(src.number, src.hash)
    };
    let key;
    for (key in src) {
        if (src[key] == null)
            continue;
        switch (key) {
            case 'number':
                header.height = src.number;
                break;
            case 'timestamp':
                header.timestamp = src.timestamp * 1000;
                break;
            case 'difficulty':
            case 'totalDifficulty':
            case 'size':
            case 'gasUsed':
            case 'gasLimit':
            case 'baseFeePerGas':
                header[key] = BigInt(src[key]);
                break;
            default:
                header[key] = src[key];
        }
    }
    return header;
}
function mapTransaction(block, src) {
    let tx = {
        id: (0, util_1.formatId)(block.height, block.hash, src.transactionIndex)
    };
    let key;
    for (key in src) {
        if (src[key] == null)
            continue;
        switch (key) {
            case 'gas':
            case 'gasPrice':
            case 'gasUsed':
            case 'cumulativeGasUsed':
            case 'effectiveGasPrice':
            case 'value':
            case 'v':
            case 'maxFeePerGas':
            case 'maxPriorityFeePerGas':
                tx[key] = BigInt(src[key]);
                break;
            case 'transactionIndex':
            case 'chainId':
            case 'yParity':
            case 'nonce':
            case 'type':
            case 'status':
                tx[key] = src[key];
                break;
            default:
                tx[key] = src[key];
        }
    }
    tx.block = block;
    return tx;
}
function mapTrace(src) {
    switch (src.type) {
        case 'create': {
            let { action, result, ...common } = src;
            let tr = common;
            if (action) {
                tr.action = {};
                let key;
                for (key in action) {
                    switch (key) {
                        case 'value':
                        case 'gas':
                            tr.action[key] = BigInt(action[key]);
                            break;
                        default:
                            tr.action[key] = action[key];
                    }
                }
            }
            if (result) {
                tr.result = {};
                let key;
                for (key in result) {
                    switch (key) {
                        case 'gasUsed':
                            tr.result.gasUsed = BigInt(result.gasUsed);
                            break;
                        default:
                            tr.result[key] = result[key];
                    }
                }
            }
            return tr;
        }
        case 'call': {
            let { action, result, ...common } = src;
            let tr = common;
            if (action) {
                tr.action = {};
                let key;
                for (key in action) {
                    switch (key) {
                        case 'gas':
                            tr.action[key] = BigInt(action[key]);
                            break;
                        case 'value':
                            let val = action[key];
                            if (val != null) {
                                tr.action[key] = BigInt(val);
                            }
                            break;
                        default:
                            tr.action[key] = action[key];
                    }
                }
            }
            if (result) {
                tr.result = {};
                let key;
                for (key in result) {
                    switch (key) {
                        case 'gasUsed':
                            tr.result.gasUsed = BigInt(result.gasUsed);
                            break;
                        default:
                            tr.result[key] = result[key];
                    }
                }
            }
            return tr;
        }
        case 'reward': {
            let { action, ...common } = src;
            let tr = common;
            if (action) {
                tr.action = {};
                let key;
                for (key in action) {
                    switch (key) {
                        case 'value':
                            tr.action.value = BigInt(action.value);
                            break;
                        default:
                            tr.action[key] = action[key];
                    }
                }
            }
            return tr;
        }
        case 'suicide': {
            let { action, ...common } = src;
            let tr = common;
            if (action) {
                tr.action = {};
                let key;
                for (key in action) {
                    switch (key) {
                        case 'balance':
                            tr.action.balance = BigInt(action.balance);
                            break;
                        default:
                            tr.action[key] = action[key];
                    }
                }
            }
            return tr;
        }
    }
}
function withDefaultFields(fields) {
    return {
        block: mergeDefaultFields(data_1.DEFAULT_FIELDS.block, fields?.block),
        transaction: mergeDefaultFields(data_1.DEFAULT_FIELDS.transaction, fields?.transaction),
        log: mergeDefaultFields(data_1.DEFAULT_FIELDS.log, fields?.log),
        trace: mergeDefaultFields(data_1.DEFAULT_FIELDS.trace, fields?.trace),
        stateDiff: mergeDefaultFields(data_1.DEFAULT_FIELDS.stateDiff, fields?.stateDiff)
    };
}
exports.withDefaultFields = withDefaultFields;
function mergeDefaultFields(defaults, selection) {
    let result = { ...defaults };
    for (let key in selection) {
        if (selection[key] != null) {
            if (selection[key]) {
                result[key] = true;
            }
            else {
                delete result[key];
            }
        }
    }
    return result;
}
//# sourceMappingURL=mapping.js.map