import { RangeRequest, SplitRequest } from '@subsquid/util-internal-range';
import { HashAndHeight, HotDatabaseState } from './database';
import { Batch, Block, BlockHeader, HotUpdate } from './datasource';
export interface HeightTracker {
    getHeight(): Promise<number>;
    getLastHeight(): number;
    wait(height: number): Promise<number>;
}
export declare class PollingHeightTracker implements HeightTracker {
    private height;
    readonly pollInterval: number;
    private lastAccess;
    private lastHeight;
    constructor(height: () => Promise<number>, pollInterval: number);
    getHeight(): Promise<number>;
    getLastHeight(): number;
    wait(height: number): Promise<number>;
}
export declare function getHeightUpdates(heightTracker: HeightTracker, from: number): AsyncIterable<number>;
export declare function generateSplitRequests<R>(args: {
    requests: RangeRequest<R>[];
    heightTracker: HeightTracker;
    stopOnHead?: boolean;
}): AsyncIterable<SplitRequest<R>>;
export declare function generateFetchStrides<R>(args: {
    requests: RangeRequest<R>[];
    heightTracker: HeightTracker;
    strideSize?: number;
    stopOnHead?: boolean;
}): AsyncIterable<SplitRequest<R>>;
export declare function archiveIngest<R, B extends Block>(args: {
    requests: RangeRequest<R>[];
    heightTracker: HeightTracker;
    query: (s: SplitRequest<R>) => Promise<B[]>;
    stopOnHead?: boolean;
}): AsyncIterable<Batch<B>>;
export interface ChainHeads {
    best?: HashAndHeight | number | string;
    finalized?: HashAndHeight | number | string;
}
export declare class ForkNavigator<B> {
    private getBlock;
    private getHeader;
    private chain;
    constructor(state: HotDatabaseState, getBlock: (ref: Partial<HashAndHeight>) => Promise<B>, getHeader: (block: B) => BlockHeader);
    private assertInvariants;
    getHeight(): number;
    move(heads: ChainHeads): Promise<HotUpdate<B>>;
    transact<R>(cb: () => Promise<R>): Promise<R>;
}
export declare class RequestsTracker<R> {
    private requests;
    constructor(requests: RangeRequest<R>[]);
    getRequestAt(height: number): R | undefined;
    hasRequestsAfter(height: number): boolean;
    splitBlocksByRequest<B>(blocks: B[], getBlockHeight: (b: B) => number): Iterable<{
        blocks: B[];
        request?: R;
    }>;
    processBlocks<I, O>(blocks: I[], getBlockHeight: (b: I) => number, process: (blocks: I[], req?: R) => Promise<O[]>): Promise<O[]>;
}
//# sourceMappingURL=ingest.d.ts.map