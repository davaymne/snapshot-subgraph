"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestsTracker = exports.ForkNavigator = exports.archiveIngest = exports.generateFetchStrides = exports.generateSplitRequests = exports.getHeightUpdates = exports.PollingHeightTracker = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const assert_1 = __importDefault(require("assert"));
class PollingHeightTracker {
    constructor(height, pollInterval) {
        this.height = height;
        this.pollInterval = pollInterval;
        this.lastAccess = 0;
        this.lastHeight = 0;
    }
    async getHeight() {
        let height = await this.height();
        this.lastAccess = Date.now();
        this.lastHeight = height;
        return height;
    }
    getLastHeight() {
        return this.lastHeight;
    }
    async wait(height) {
        let current = this.lastHeight;
        while (current < height) {
            let pause = this.pollInterval - Math.min(Date.now() - this.lastAccess, this.pollInterval);
            if (pause) {
                await (0, util_internal_1.wait)(pause);
            }
            current = await this.getHeight();
        }
        return current;
    }
}
exports.PollingHeightTracker = PollingHeightTracker;
async function* getHeightUpdates(heightTracker, from) {
    while (true) {
        yield from = await heightTracker.wait(from);
        from += 1;
    }
}
exports.getHeightUpdates = getHeightUpdates;
async function* generateSplitRequests(args) {
    let top = args.heightTracker.getLastHeight();
    for (let req of args.requests) {
        let from = req.range.from;
        let end = req.range.to ?? Infinity;
        while (from <= end) {
            if (top < from) {
                top = await args.heightTracker.getHeight();
                if (top < from) {
                    if (args.stopOnHead)
                        return;
                    top = await args.heightTracker.wait(from);
                }
            }
            let to = Math.min(end, top);
            yield {
                range: { from, to },
                request: req.request
            };
            from = to + 1;
        }
    }
}
exports.generateSplitRequests = generateSplitRequests;
async function* generateFetchStrides(args) {
    let { strideSize = 10, ...params } = args;
    for await (let s of generateSplitRequests(params)) {
        for (let range of (0, util_internal_range_1.splitRange)(strideSize, s.range)) {
            yield {
                range,
                request: s.request
            };
        }
    }
}
exports.generateFetchStrides = generateFetchStrides;
function archiveIngest(args) {
    let { query, ...params } = args;
    async function* ingest() {
        for await (let s of generateSplitRequests(params)) {
            let from = s.range.from;
            let to = s.range.to;
            while (from <= to) {
                let blocks = await query({
                    range: { from, to },
                    request: s.request
                });
                (0, assert_1.default)(blocks.length > 0, 'boundary blocks are expected to be included');
                let top = (0, util_internal_1.last)(blocks).header.height;
                yield { blocks, isHead: top >= args.heightTracker.getLastHeight() };
                from = top + 1;
            }
        }
    }
    return (0, util_internal_1.concurrentMap)(2, ingest(), b => Promise.resolve(b));
}
exports.archiveIngest = archiveIngest;
class ForkNavigator {
    constructor(state, getBlock, getHeader) {
        this.getBlock = getBlock;
        this.getHeader = getHeader;
        this.chain = [state, ...state.top];
        this.assertInvariants();
    }
    assertInvariants() {
        for (let i = 1; i < this.chain.length; i++) {
            (0, assert_1.default)(this.chain[i].height == this.chain[i - 1].height + 1);
        }
    }
    getHeight() {
        return (0, util_internal_1.last)(this.chain).height;
    }
    async move(heads) {
        let chain = this.chain.slice();
        let newBlocks = [];
        let bestHead;
        if (typeof heads.best == 'number') {
            if (heads.best > (0, util_internal_1.last)(chain).height) {
                let newBlock = await this.getBlock({ height: heads.best });
                newBlocks.push(newBlock);
                bestHead = getParent(this.getHeader(newBlock));
            }
        }
        else if (typeof heads.best == 'string') {
            bestHead = chain.find(ref => ref.hash === heads.best);
            bestHead = bestHead || await this.getBlock({ hash: heads.best }).then(b => this.getHeader(b));
        }
        else {
            bestHead = heads.best;
        }
        if (bestHead) {
            (0, assert_1.default)(bestHead.height >= chain[0].height);
            if ((0, util_internal_1.last)(chain).height > bestHead.height) {
                let bestPos = bestHead.height - chain[0].height;
                if (chain[bestPos].hash === bestHead.hash) {
                    // no fork
                }
                else {
                    // we have a proper fork
                    chain = chain.slice(0, bestPos);
                }
            }
            while ((0, util_internal_1.last)(chain).height < bestHead.height) {
                let block = await this.getBlock(bestHead);
                newBlocks.push(block);
                bestHead = getParent(this.getHeader(block));
            }
            while ((0, util_internal_1.last)(chain).hash !== bestHead.hash) {
                let block = await this.getBlock(bestHead);
                newBlocks.push(block);
                bestHead = getParent(this.getHeader(block));
                chain.pop();
            }
        }
        newBlocks = newBlocks.reverse();
        for (let block of newBlocks) {
            chain.push(this.getHeader(block));
        }
        let finalizedHead;
        if (typeof heads.finalized == 'number') {
            (0, assert_1.default)(heads.finalized <= (0, util_internal_1.last)(chain).height);
            if (heads.finalized > chain[0].height) {
                finalizedHead = chain[heads.finalized - chain[0].height];
                (0, assert_1.default)(finalizedHead.height == heads.finalized);
            }
        }
        else if (typeof heads.finalized == 'string') {
            finalizedHead = chain.find(ref => ref.hash === heads.finalized);
            finalizedHead = finalizedHead || await this.getBlock({ hash: heads.finalized }).then(b => this.getHeader(b));
        }
        else {
            finalizedHead = heads.finalized;
        }
        if (finalizedHead && finalizedHead.height >= chain[0].height) {
            (0, assert_1.default)(finalizedHead.height <= (0, util_internal_1.last)(chain).height);
            let finalizedHeadPos = finalizedHead.height - chain[0].height;
            (0, assert_1.default)(chain[finalizedHeadPos].hash === finalizedHead.hash);
            chain = chain.slice(finalizedHeadPos);
        }
        // don't change the state until no error is guaranteed to occur
        this.chain = chain;
        return {
            blocks: newBlocks,
            baseHead: newBlocks.length ? getParent(this.getHeader(newBlocks[0])) : (0, util_internal_1.last)(this.chain),
            finalizedHead: this.chain[0]
        };
    }
    async transact(cb) {
        let chain = this.chain;
        try {
            return await cb();
        }
        catch (err) {
            this.chain = chain;
            throw err;
        }
    }
}
exports.ForkNavigator = ForkNavigator;
function getParent(hdr) {
    return {
        hash: hdr.parentHash,
        height: hdr.height - 1
    };
}
class RequestsTracker {
    constructor(requests) {
        this.requests = requests;
    }
    getRequestAt(height) {
        for (let req of this.requests) {
            let from = req.range.from;
            let to = req.range.to ?? Infinity;
            if (from <= height && height <= to)
                return req.request;
        }
    }
    hasRequestsAfter(height) {
        for (let req of this.requests) {
            let to = req.range.to ?? Infinity;
            if (height < to)
                return true;
        }
        return false;
    }
    *splitBlocksByRequest(blocks, getBlockHeight) {
        let pack = [];
        let packRequest = undefined;
        for (let b of blocks) {
            let req = this.getRequestAt(getBlockHeight(b));
            if (req === packRequest) {
                pack.push(b);
            }
            else {
                if (pack.length) {
                    yield { blocks: pack, request: packRequest };
                }
                pack = [b];
                packRequest = req;
            }
        }
        if (pack.length) {
            yield { blocks: pack, request: packRequest };
        }
    }
    async processBlocks(blocks, getBlockHeight, process) {
        let result = [];
        for (let pack of this.splitBlocksByRequest(blocks, getBlockHeight)) {
            result.push(...await process(pack.blocks, pack.request));
        }
        return result;
    }
}
exports.RequestsTracker = RequestsTracker;
//# sourceMappingURL=ingest.js.map