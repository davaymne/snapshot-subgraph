import type { Logger } from '@subsquid/logger';
import type { Headers, RequestInit, Response } from 'node-fetch';
import { AgentProvider } from './agent';
import { HttpBody } from './body';
export { HttpBody };
export interface HttpClientOptions {
    agent?: AgentProvider;
    baseUrl?: string;
    headers?: Record<string, string | number | bigint>;
    /**
     * Default request timeout in milliseconds.
     *
     * This timeout is only related to individual http requests.
     * Overall request processing time might be much larger due to retries.
     */
    httpTimeout?: number;
    retryAttempts?: number;
    retrySchedule?: number[];
    log?: Logger | null;
}
export interface RequestOptions {
    query?: Record<string, string | number | bigint>;
    headers?: HeadersInit;
    retryAttempts?: number;
    retrySchedule?: number[];
    httpTimeout?: number;
    abort?: AbortSignal;
    stream?: boolean;
}
export interface GraphqlRequestOptions extends RequestOptions {
    variables?: Record<string, any>;
    url?: string;
    method?: 'GET' | 'POST';
}
export interface FetchRequest extends RequestInit {
    id: number;
    url: string;
    headers: Headers;
    timeout?: number;
    signal?: AbortSignal;
    stream?: boolean;
}
export declare class HttpClient {
    protected log?: Logger;
    protected headers?: Record<string, string | number | bigint>;
    private baseUrl?;
    private agent;
    private retrySchedule;
    private retryAttempts;
    private httpTimeout;
    private requestCounter;
    constructor(options?: HttpClientOptions);
    get<T = any>(url: string, options?: RequestOptions): Promise<T>;
    post<T = any>(url: string, options?: RequestOptions & HttpBody): Promise<T>;
    request<T = any>(method: string, url: string, options?: RequestOptions & HttpBody): Promise<HttpResponse<T>>;
    protected beforeRequest(req: FetchRequest): void;
    protected beforeRetryPause(req: FetchRequest, reason: Error | HttpResponse, pause: number): void;
    protected afterResponseHeaders(req: FetchRequest, url: string, status: number, headers: Headers): void;
    protected afterResponse(req: FetchRequest, res: HttpResponse): void;
    protected prepareRequest(method: string, url: string, options: RequestOptions & HttpBody): Promise<FetchRequest>;
    private handleBasicAuth;
    private performRequestWithTimeout;
    private performRequest;
    protected handleResponseBody(req: FetchRequest, res: Response): Promise<any>;
    isRetryableError(error: HttpResponse | Error, req?: FetchRequest): boolean;
    private getRequestUrlAndAuth;
    getAbsUrl(url: string): string;
    private setBaseUrl;
    graphqlRequest<T = any>(gql: string, options?: GraphqlRequestOptions): Promise<T>;
}
export declare class HttpResponse<T = any> {
    readonly requestId: number;
    readonly url: string;
    readonly status: number;
    readonly headers: Headers;
    readonly body: T;
    readonly stream: boolean;
    constructor(requestId: number, url: string, status: number, headers: Headers, body: T, stream: boolean);
    get ok(): boolean;
    assert(): void;
    toJSON(): {
        status: number;
        headers: [string, string][];
        body: T | undefined;
        url: string;
    };
}
export declare class HttpError extends Error {
    readonly response: HttpResponse;
    constructor(response: HttpResponse);
    get name(): string;
}
export declare class HttpTimeoutError extends Error {
    readonly ms: number;
    constructor(ms: number);
    get name(): string;
}
export interface GraphqlMessage {
    message: string;
    path?: (string | number)[];
}
export declare class GraphqlError extends Error {
    readonly messages: GraphqlMessage[];
    constructor(messages: GraphqlMessage[]);
    get name(): string;
}
export declare function isHttpConnectionError(err: unknown): boolean;
//# sourceMappingURL=client.d.ts.map