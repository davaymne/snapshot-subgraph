"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHttpConnectionError = exports.GraphqlError = exports.HttpTimeoutError = exports.HttpError = exports.HttpResponse = exports.HttpClient = void 0;
const logger_1 = require("@subsquid/logger");
const util_internal_1 = require("@subsquid/util-internal");
const agent_1 = require("./agent");
const request_1 = require("./request");
class HttpClient {
    constructor(options = {}) {
        this.requestCounter = 0;
        this.log = options.log === null ? undefined : options.log || (0, logger_1.createLogger)('sqd:http-client');
        this.headers = options.headers;
        this.setBaseUrl(options.baseUrl);
        this.agent = options.agent || agent_1.defaultAgentProvider;
        this.retrySchedule = options.retrySchedule || [10, 100, 500, 2000, 10000, 20000];
        this.retryAttempts = options.retryAttempts || 0;
        this.httpTimeout = options.httpTimeout ?? 20000;
    }
    get(url, options) {
        return this.request('GET', url, options).then(res => res.body);
    }
    post(url, options) {
        return this.request('POST', url, options).then(res => res.body);
    }
    async request(method, url, options = {}) {
        let req = await this.prepareRequest(method, url, options);
        this.beforeRequest(req);
        let retryAttempts = options.retryAttempts ?? this.retryAttempts;
        let retrySchedule = options.retrySchedule ?? this.retrySchedule;
        let retries = 0;
        while (true) {
            let res = await this.performRequestWithTimeout(req).catch(util_internal_1.ensureError);
            if (res instanceof Error || !res.ok) {
                if (retryAttempts > retries && this.isRetryableError(res, req)) {
                    let pause = retrySchedule.length
                        ? retrySchedule[Math.min(retries, retrySchedule.length - 1)]
                        : 1000;
                    retries += 1;
                    this.beforeRetryPause(req, res, pause);
                    await (0, util_internal_1.wait)(pause, req.signal);
                }
                else if (res instanceof Error) {
                    throw (0, util_internal_1.addErrorContext)(res, { httpRequestId: req.id });
                }
                else {
                    throw new HttpError(res);
                }
            }
            else {
                return res;
            }
        }
    }
    beforeRequest(req) {
        if (this.log?.isDebug()) {
            this.log.debug({
                httpRequestId: req.id,
                httpRequestUrl: req.url,
                httpRequestMethod: req.method,
                httpRequestHeaders: Array.from(req.headers),
                httpRequestBody: req.body
            }, 'http request');
        }
    }
    beforeRetryPause(req, reason, pause) {
        if (this.log?.isWarn()) {
            let info = {
                httpRequestId: req.id,
                httpRequestUrl: req.url,
                httpRequestMethod: req.method
            };
            if (reason instanceof Error) {
                info.reason = reason.toString();
            }
            else {
                info.reason = `got ${reason.status}`;
                info.httpResponseUrl = reason.url;
                info.httpResponseStatus = reason.status;
                info.httpResponseHeaders = Array.from(reason.headers);
                info.httpResponseBody = reason.body;
            }
            this.log.warn(info, `request will be retried in ${pause} ms`);
        }
    }
    afterResponseHeaders(req, url, status, headers) {
        if (this.log?.isDebug()) {
            this.log.debug({
                httpRequestId: req.id,
                httpResponseUrl: url,
                httpResponseStatus: status,
                httpResponseHeaders: Array.from(headers)
            }, 'http headers');
        }
    }
    afterResponse(req, res) {
        if (!res.stream && this.log?.isDebug()) {
            let httpResponseBody = res.body;
            if (typeof res.body == 'string' || res.body instanceof Uint8Array) {
                if (res.body.length > 1024 * 1024) {
                    httpResponseBody = '...body is too long to be logged';
                }
            }
            this.log.debug({
                httpRequestId: req.id,
                httpResponseBody
            }, 'http body');
        }
    }
    async prepareRequest(method, url, options) {
        await request_1.nodeFetch.load();
        let req = {
            id: this.requestCounter++,
            method,
            headers: new request_1.nodeFetch.Headers(options.headers),
            url: this.getAbsUrl(url),
            signal: options.abort,
            compress: true,
            timeout: options.httpTimeout ?? this.httpTimeout,
            stream: options.stream
        };
        this.handleBasicAuth(req);
        if (options.query) {
            let qs = new URLSearchParams(options.query).toString();
            if (req.url.includes('?')) {
                req.url += '&' + qs;
            }
            else {
                req.url += '?' + qs;
            }
        }
        req.agent = this.agent.getNativeAgent(req.url);
        if (options.content !== undefined) {
            if (typeof options.content == 'string') {
                req.body = options.content;
                if (!req.headers.has('content-type')) {
                    req.headers.set('content-type', 'text/plain');
                }
            }
            else if (Buffer.isBuffer(options.content)) {
                req.body = options.content;
            }
            else {
                req.body = Buffer.from(options.content.buffer, options.content.byteOffset, options.content.byteLength);
            }
        }
        if (options.json !== undefined) {
            req.body = JSON.stringify(options.json);
            if (!req.headers.has('content-type')) {
                req.headers.set('content-type', 'application/json');
            }
        }
        for (let name in this.headers) {
            if (!req.headers.has(name)) {
                req.headers.set(name, '' + this.headers[name]);
            }
        }
        return req;
    }
    handleBasicAuth(req) {
        let u = new URL(req.url);
        if (u.username || u.password) {
            req.headers.set('Authorization', `Basic ${btoa(u.username + ':' + u.password)}`);
            u.username = '';
            u.password = '';
            req.url = u.toString();
        }
    }
    async performRequestWithTimeout(req) {
        if (!req.timeout)
            return this.performRequest(req);
        let ac = new AbortController();
        function abort() {
            ac.abort();
        }
        req.signal?.addEventListener('abort', abort);
        let timer = setTimeout(() => {
            timer = null;
            abort();
        }, req.timeout);
        try {
            return await this.performRequest({ ...req, signal: ac.signal });
        }
        catch (err) {
            if (timer == null) {
                throw new HttpTimeoutError(req.timeout);
            }
            else {
                throw err;
            }
        }
        finally {
            if (timer != null) {
                clearTimeout(timer);
            }
        }
    }
    async performRequest(req) {
        let res = await request_1.nodeFetch.request(req.url, req);
        this.afterResponseHeaders(req, res.url, res.status, res.headers);
        let httpResponse;
        if (req.stream && res.ok) {
            httpResponse = new HttpResponse(req.id, res.url, res.status, res.headers, res.body, res.body != null);
        }
        else {
            let body = await this.handleResponseBody(req, res);
            httpResponse = new HttpResponse(req.id, res.url, res.status, res.headers, body, false);
        }
        this.afterResponse(req, httpResponse);
        return httpResponse;
    }
    async handleResponseBody(req, res) {
        let contentType = (res.headers.get('content-type') || '').split(';')[0];
        if (contentType == 'application/json') {
            return res.json();
        }
        if (contentType.startsWith('text/')) {
            return res.text();
        }
        let arrayBuffer = await res.arrayBuffer();
        if (arrayBuffer.byteLength == 0)
            return undefined;
        return Buffer.from(arrayBuffer);
    }
    isRetryableError(error, req) {
        if (isHttpConnectionError(error))
            return true;
        if (error instanceof HttpTimeoutError)
            return true;
        if (error instanceof HttpError) {
            error = error.response;
        }
        if (error instanceof HttpResponse) {
            switch (error.status) {
                case 429:
                case 502:
                case 503:
                case 504:
                    return true;
                default:
                    return false;
            }
        }
        return false;
    }
    getRequestUrlAndAuth(url) {
        let u = new URL(this.getAbsUrl(url));
        if (u.username || u.password) {
            let basic = btoa(u.username + ':' + u.password);
            u.username = '';
            u.password = '';
            return { url: u.toString(), basic };
        }
        else {
            return { url: u.toString() };
        }
    }
    getAbsUrl(url) {
        if (!this.baseUrl)
            return url;
        if (url.includes('://'))
            return url;
        if (url == '/')
            return this.baseUrl;
        if (url[0] == '/')
            return this.baseUrl + url;
        return this.baseUrl + '/' + url;
    }
    setBaseUrl(url) {
        if (url) {
            let u = new URL(url);
            u.hash = '';
            u.search = '';
            url = u.toString();
            if (url.endsWith('/')) {
                url = url.slice(0, url.length - 1);
            }
            this.baseUrl = url;
        }
        else {
            this.baseUrl = undefined;
        }
    }
    async graphqlRequest(gql, options = {}) {
        let { method = 'POST', url = '/', variables, ...reqOptions } = options;
        let req = reqOptions;
        if (method == 'GET') {
            req.query = {
                ...req.query,
                query: gql,
            };
            if (variables) {
                req.query.variables = JSON.stringify(variables);
            }
        }
        else {
            req.json = {
                query: gql,
                variables
            };
        }
        let res = await this.request(method, url, req);
        if (res.body.errors?.length) {
            throw new GraphqlError(res.body.errors);
        }
        else {
            return res.body.data;
        }
    }
}
exports.HttpClient = HttpClient;
class HttpResponse {
    constructor(requestId, url, status, headers, body, stream) {
        this.requestId = requestId;
        this.url = url;
        this.status = status;
        this.headers = headers;
        this.body = body;
        this.stream = stream;
    }
    get ok() {
        return this.status >= 200 && this.status < 300;
    }
    assert() {
        if (this.ok)
            return;
        throw new HttpError(this);
    }
    toJSON() {
        return {
            status: this.status,
            headers: Array.from(this.headers),
            body: this.stream ? undefined : this.body,
            url: this.url
        };
    }
}
exports.HttpResponse = HttpResponse;
class HttpError extends Error {
    constructor(response) {
        super(`Got ${response.status} from ${response.url}`);
        this.response = response;
    }
    get name() {
        return 'HttpError';
    }
}
exports.HttpError = HttpError;
class HttpTimeoutError extends Error {
    constructor(ms) {
        super(`request timed out after ${ms} ms`);
        this.ms = ms;
    }
    get name() {
        return 'HttpTimeoutError';
    }
}
exports.HttpTimeoutError = HttpTimeoutError;
class GraphqlError extends Error {
    constructor(messages) {
        super(`GraphQL error: ${messages[0].message}`);
        this.messages = messages;
    }
    get name() {
        return 'GraphqlError';
    }
}
exports.GraphqlError = GraphqlError;
function isHttpConnectionError(err) {
    return request_1.nodeFetch.isLoaded
        && err instanceof request_1.nodeFetch.FetchError
        && err.type == 'system'
        && (err.message.startsWith('request to') || err.code == 'ERR_STREAM_PREMATURE_CLOSE');
}
exports.isHttpConnectionError = isHttpConnectionError;
//# sourceMappingURL=client.js.map