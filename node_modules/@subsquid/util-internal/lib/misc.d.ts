export declare function assertNotNull<T>(val: T | undefined | null, msg?: string): T;
export declare function unexpectedCase(val?: unknown): Error;
export declare function last<T>(array: T[]): T;
export declare function maybeLast<T>(array: T[]): T | undefined;
export declare function runProgram(main: () => Promise<void>, log?: (err: Error) => void): void;
export declare class NonErrorThrow extends Error {
    readonly value: unknown;
    constructor(value: unknown);
}
export declare function ensureError(val: unknown): Error;
export declare function addErrorContext<T extends Error>(err: T, ctx: any): T;
export declare function withErrorContext(ctx: any): (err: Error) => never;
export declare function annotateSyncError(getCtx: (...args: any[]) => any): (proto: any, prop: string, d: PropertyDescriptor) => PropertyDescriptor;
export declare function annotateAsyncError(getCtx: (...args: any[]) => any): (proto: any, prop: string, d: PropertyDescriptor) => PropertyDescriptor;
export declare function wait(ms: number, abortSignal?: AbortSignal): Promise<void>;
export declare function groupBy<T, G>(elements: Iterable<T>, group: (e: T) => G): Map<G, T[]>;
export declare function splitSlice(maxSize: number, beg: number, end?: number): Iterable<[beg: number, end: number]>;
export declare function splitArray<T>(maxSize: number, arr: T[]): Iterable<T[]>;
export declare function splitParallelWork<T, R>(maxSize: number, tasks: T[], run: (tasks: T[]) => Promise<R[]>): Promise<R[]>;
//# sourceMappingURL=misc.d.ts.map