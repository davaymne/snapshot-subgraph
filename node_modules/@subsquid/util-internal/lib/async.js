"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.concurrentMap = exports.AsyncQueue = exports.ClosedQueueError = exports.createFuture = void 0;
const assert_1 = __importDefault(require("assert"));
const misc_1 = require("./misc");
function createFuture() {
    let future;
    let promise = new Promise((resolve, reject) => {
        future = {
            resolve,
            reject,
            promise: () => promise
        };
    });
    return (0, misc_1.assertNotNull)(future);
}
exports.createFuture = createFuture;
class ClosedQueueError extends Error {
    constructor() {
        super('Queue was closed, no more puts are allowed!');
    }
    get name() {
        return 'AsyncQueueWasClosed';
    }
}
exports.ClosedQueueError = ClosedQueueError;
class AsyncQueue {
    constructor(size) {
        this.pos = 0;
        this.size = 0;
        this.closed = false;
        this.buf = new Array(size);
    }
    async put(val) {
        if (this.closed)
            throw new ClosedQueueError();
        if (this.takeFuture) {
            this.takeFuture.resolve(val);
            this.takeFuture = undefined;
        }
        else if (this.size < this.buf.length) {
            this.putToBuffer(val);
        }
        else {
            (0, assert_1.default)(this.putFuture == null, 'Concurrent puts are not allowed');
            this.putFuture = createFuture();
            await this.putFuture.promise();
            this.putToBuffer(val);
        }
    }
    putToBuffer(val) {
        (0, assert_1.default)(this.size < this.buf.length);
        this.buf[(this.pos + this.size) % this.buf.length] = val;
        this.size += 1;
    }
    async take() {
        if (this.putFuture) {
            this.putFuture.resolve();
            this.putFuture = undefined;
        }
        if (this.size > 0) {
            let val = this.buf[this.pos];
            this.buf[this.pos] = undefined;
            this.pos = (this.pos + 1) % this.buf.length;
            this.size -= 1;
            return val;
        }
        else if (this.closed) {
            return undefined;
        }
        else {
            (0, assert_1.default)(this.takeFuture == null, 'Concurrent takes are not allowed');
            this.takeFuture = createFuture();
            return this.takeFuture.promise();
        }
    }
    close() {
        this.closed = true;
        if (this.putFuture) {
            this.putFuture.reject(new ClosedQueueError());
            this.putFuture = undefined;
        }
        if (this.takeFuture) {
            this.takeFuture.resolve(undefined);
            this.takeFuture = undefined;
        }
    }
    async *iterate() {
        while (true) {
            let val = await this.take();
            if (val === undefined)
                return;
            yield val;
        }
    }
}
exports.AsyncQueue = AsyncQueue;
async function* concurrentMap(concurrency, stream, f) {
    (0, assert_1.default)(concurrency > 1);
    let queue = new AsyncQueue(concurrency - 1);
    async function map() {
        for await (let val of stream) {
            let promise = f(val);
            promise.catch(() => { }); // prevent unhandled rejection crashes
            await queue.put({ promise });
        }
    }
    map().then(() => queue.close(), err => queue.put({ promise: Promise.reject(err) }));
    for await (let item of queue.iterate()) {
        yield await item.promise;
    }
}
exports.concurrentMap = concurrentMap;
//# sourceMappingURL=async.js.map