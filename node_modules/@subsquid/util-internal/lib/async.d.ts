export interface Future<T> {
    resolve: (val: T) => void;
    reject: (err: Error) => void;
    promise: () => Promise<T>;
}
export declare function createFuture<T>(): Future<T>;
export declare class ClosedQueueError extends Error {
    constructor();
    get name(): string;
}
export declare class AsyncQueue<T> {
    private buf;
    private pos;
    private size;
    private closed;
    private putFuture?;
    private takeFuture?;
    constructor(size: number);
    put(val: T): Promise<void>;
    private putToBuffer;
    take(): Promise<T | undefined>;
    close(): void;
    iterate(): AsyncIterable<T>;
}
export declare function concurrentMap<T, R>(concurrency: number, stream: AsyncIterable<T>, f: (val: T) => Promise<R>): AsyncIterable<R>;
//# sourceMappingURL=async.d.ts.map