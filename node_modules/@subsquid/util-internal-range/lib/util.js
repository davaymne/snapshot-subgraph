"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printRange = exports.applyRangeBound = exports.mergeRangeRequests = exports.getSize = exports.assertRangeList = exports.splitRange = exports.rangeDifference = exports.rangeIntersection = exports.rangeContains = exports.rangeEnd = exports.assertRange = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_binary_heap_1 = require("@subsquid/util-internal-binary-heap");
const assert_1 = __importDefault(require("assert"));
function assertRange(range) {
    (0, assert_1.default)(Number.isSafeInteger(range.from));
    (0, assert_1.default)(range.to == null || Number.isSafeInteger(range.to));
    (0, assert_1.default)(range.from >= 0);
    (0, assert_1.default)(range.from <= rangeEnd(range));
}
exports.assertRange = assertRange;
function rangeEnd(range) {
    return range.to ?? Infinity;
}
exports.rangeEnd = rangeEnd;
function rangeContains(big, small) {
    return big.from <= small.from && rangeEnd(big) >= rangeEnd(small);
}
exports.rangeContains = rangeContains;
function rangeIntersection(a, b) {
    let beg = Math.max(a.from, b.from);
    let end = Math.min(rangeEnd(a), rangeEnd(b));
    if (beg > end)
        return undefined;
    if (end === Infinity) {
        return { from: beg };
    }
    else {
        return { from: beg, to: end };
    }
}
exports.rangeIntersection = rangeIntersection;
function rangeDifference(a, b) {
    let i = rangeIntersection(a, b);
    if (i == null)
        return [a];
    let result = [];
    if (a.from < i.from) {
        result.push({ from: a.from, to: i.from - 1 });
    }
    if (i.to != null && i.to < rangeEnd(a)) {
        let from = i.to + 1;
        if (a.to) {
            result.push({ from, to: a.to });
        }
        else {
            result.push({ from });
        }
    }
    return result;
}
exports.rangeDifference = rangeDifference;
function* splitRange(maxSize, range) {
    for (let [beg, end] of (0, util_internal_1.splitSlice)(maxSize, range.from, range.to == null ? undefined : range.to + 1)) {
        yield {
            from: beg,
            to: end - 1
        };
    }
}
exports.splitRange = splitRange;
function assertRangeList(ranges) {
    if (ranges.length == 0)
        return;
    assertRange(ranges[0]);
    for (let i = 1; i < ranges.length; i++) {
        assertRange(ranges[i]);
        (0, assert_1.default)(ranges[i].from > rangeEnd(ranges[i - 1]));
    }
}
exports.assertRangeList = assertRangeList;
function getSize(ranges, boundary) {
    let size = 0;
    for (let range of ranges) {
        if (boundary.to < range.from)
            return size;
        if (boundary.from > rangeEnd(range))
            continue;
        let beg = Math.max(boundary.from, range.from);
        let end = Math.min(boundary.to, rangeEnd(range));
        size += end - beg + 1;
    }
    return size;
}
exports.getSize = getSize;
function mergeRangeRequests(requests, merge) {
    if (requests.length <= 1)
        return requests;
    let union = [];
    let heap = new util_internal_binary_heap_1.Heap((a, b) => a.range.from - b.range.from);
    heap.init(requests.slice());
    let top = heap.pop();
    let req;
    while (req = heap.peek()) {
        let i = rangeIntersection(top.range, req.range);
        if (i == null) {
            union.push(top);
            top = (0, util_internal_1.assertNotNull)(heap.pop());
        }
        else {
            heap.pop();
            rangeDifference(top.range, i).forEach(range => {
                heap.push({ range, request: top.request });
            });
            rangeDifference(req.range, i).forEach(range => {
                heap.push({ range, request: req.request });
            });
            heap.push({
                range: i,
                request: merge(top.request, req.request)
            });
            top = (0, util_internal_1.assertNotNull)(heap.pop());
        }
    }
    union.push(top);
    return union;
}
exports.mergeRangeRequests = mergeRangeRequests;
function applyRangeBound(requests, range) {
    if (range == null)
        return requests;
    let result = [];
    for (let req of requests) {
        let i = rangeIntersection(range, req.range);
        if (i) {
            result.push({ range: i, request: req.request });
        }
    }
    return result;
}
exports.applyRangeBound = applyRangeBound;
function printRange(range) {
    if (range?.to != null) {
        return `[${range.from}, ${range.to}]`;
    }
    else {
        return `[${range?.from ?? 0})`;
    }
}
exports.printRange = printRange;
//# sourceMappingURL=util.js.map