"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const ethers = __importStar(require("ethers"));
const path_1 = __importDefault(require("path"));
const commander_1 = require("commander");
const logger_1 = require("@subsquid/logger");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_code_printer_1 = require("@subsquid/util-internal-code-printer");
const validator = __importStar(require("@subsquid/util-internal-commander"));
const typegen_1 = require("./typegen");
const fetch_1 = require("./util/fetch");
const LOG = (0, logger_1.createLogger)('sqd:evm-typegen');
(0, util_internal_1.runProgram)(async function () {
    commander_1.program
        .description(`
Generates TypeScript facades for EVM transactions, logs and eth_call queries.

The generated facades are assumed to be used by "squids" indexing EVM data.
    `.trim())
        .name('squid-evm-typegen')
        .argument('<output-dir>', 'output directory for generated definitions')
        .argument('[abi...]', 'ABI file', specArgument)
        .option('--multicall', 'generate facade for MakerDAO multicall contract')
        .option('--etherscan-api <url>', 'etherscan API to fetch contract ABI by a known address', validator.Url(['http:', 'https:']))
        .option('--etherscan-api-key <key>', 'etherscan API key')
        .option('--clean', 'delete output directory before run')
        .addHelpText('afterAll', `
ABI file can be specified in three ways:

1. as a plain JSON file:

squid-evm-typegen src/abi erc20.json

2. as a contract address (to fetch ABI from etherscan)

squid-evm-typegen src/abi 0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413

3. as an arbitrary http url

squid-evm-typegen src/abi https://example.com/erc721.json

In all cases typegen will use ABI's basename as a basename of generated files.
You can overwrite basename of generated files using fragment (#) suffix.

squid-evm-typegen src/abi 0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413#contract   
        `);
    commander_1.program.parse();
    let opts = commander_1.program.opts();
    let dest = new util_internal_code_printer_1.OutDir(commander_1.program.processedArgs[0]);
    let specs = commander_1.program.processedArgs[1];
    if (opts.clean && dest.exists()) {
        LOG.info(`deleting ${dest.path()}`);
        dest.del();
    }
    if (specs.length == 0 && !opts.multicall) {
        LOG.warn('no ABI files given, nothing to generate');
        return;
    }
    dest.add('abi.support.ts', [__dirname, '../src/abi.support.ts']);
    LOG.info(`saved ${dest.path('abi.support.ts')}`);
    if (opts.multicall) {
        dest.add('multicall.ts', [__dirname, '../src/multicall.ts']);
        LOG.info(`saved ${dest.path('multicall.ts')}`);
    }
    for (let spec of specs) {
        LOG.info(`processing ${spec.src}`);
        let abi_json = await read(spec, opts);
        let abi = new ethers.Interface(abi_json);
        new typegen_1.Typegen(dest, abi, spec.name, LOG).generate();
    }
}, err => LOG.fatal(err));
async function read(spec, options) {
    if (spec.kind == 'address') {
        return fetchFromEtherscan(spec.src, options?.etherscanApi, options?.etherscanApiKey);
    }
    let abi;
    if (spec.kind == 'url') {
        abi = await (0, fetch_1.GET)(spec.src);
    }
    else {
        abi = JSON.parse(fs.readFileSync(spec.src, 'utf-8'));
    }
    if (Array.isArray(abi)) {
        return abi;
    }
    else if (Array.isArray(abi?.abi)) {
        return abi.abi;
    }
    else {
        throw new Error('Unrecognized ABI format');
    }
}
async function fetchFromEtherscan(address, api, apiKey) {
    api = api || 'https://api.etherscan.io/';
    let url = new URL('api?module=contract&action=getabi', api);
    url.searchParams.set('address', address);
    if (apiKey) {
        url.searchParams.set('apiKey', apiKey);
    }
    let response;
    let attempts = 0;
    while (true) {
        response = await (0, fetch_1.GET)(url.toString());
        if (response.status == '0' && response.result.includes('rate limit') && attempts < 4) {
            attempts += 1;
            let timeout = attempts * 2;
            LOG.warn(`faced rate limit error while trying to fetch contract ABI. Trying again in ${timeout} seconds.`);
            await (0, util_internal_1.wait)(timeout * 1000);
        }
        else {
            break;
        }
    }
    if (response.status == '1') {
        return JSON.parse(response.result);
    }
    else {
        throw new Error(`Failed to fetch contract ABI from ${api}: ${response.result}`);
    }
}
function specArgument(value, prev) {
    let spec = parseSpec(value);
    prev = prev || [];
    prev.push(spec);
    return prev;
}
function parseSpec(spec) {
    let [src, fragment] = splitFragment(spec);
    if (src.startsWith('0x')) {
        if (!ethers.isAddress(src))
            throw new commander_1.InvalidArgumentError('Invalid contract address');
        return {
            kind: 'address',
            src,
            name: fragment || src
        };
    }
    else if (src.includes('://')) {
        let u = new URL(validator.Url(['http:', 'https:'])(src));
        return {
            kind: 'url',
            src,
            name: fragment || basename(u.pathname)
        };
    }
    else {
        return {
            kind: 'file',
            src,
            name: fragment || basename(src)
        };
    }
}
function splitFragment(spec) {
    let parts = spec.split('#');
    if (parts.length > 1) {
        let fragment = parts.pop();
        return [parts.join('#'), fragment];
    }
    else {
        return [spec, ''];
    }
}
function basename(file) {
    let name = path_1.default.parse(file).name;
    if (name)
        return name;
    throw new commander_1.InvalidArgumentError(`Can't derive target basename for output files. Use url fragment to specify it, e.g. #erc20`);
}
//# sourceMappingURL=main.js.map